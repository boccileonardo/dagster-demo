- Handle arbitrary retailer column not fitting in data model
- separate fact dim with multiple dates (3 files on each date)
- multiple file handling for each date
- slowly changing dimensions T2
- incremental file triggering (only process new files detected by sensor)
- Surrogate key implementation:
- hash is made of all natural keys in source data + retailer id + updated_at timestamp. Additionally natural prod_id and site_id are prefixed by retailer id.
- if bronze is a single table (not split in dim and fact), hash the natural keys for a dimension object and then save the key generated by the hashing into both dim and fact.
- if bronze is in multiple tables (fact + dim), hash the natural keys (including updated_at) in the dimension to generate the key, then use the natural key in fact to lookup the dimension and join to get the surrogate key.
- date-level observability of retailer data completeness
- Antitrust implementation in silver layer
- Onboard more retailers
- Onboard more data sources (API and databricks)
- Fake table(asset) registration on unity catalog and on metadata DB in gold layer
- Use a data quality library to run dq checks in silver and add more dq checks (currently only schema check)
- dimension level anomalies
- Unit tests
